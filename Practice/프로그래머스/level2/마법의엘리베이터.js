// 155 => 11
//
function solution(storey) {
  let answer = 0

  while (storey) {
    let cur = storey % 10
    let next = Math.floor(storey / 10) % 10

    if (cur > 5) {
      answer += 10 - cur
      storey += 10
    } else if (cur === 5) {
      answer += 5
      storey += next >= 5 ? 10 : 0 // 1
    } else {
      answer += cur
    }
    storey = Math.floor(storey / 10)
  }

  return answer
}

// 5 + 4 + 2 => 11

function solution(storey) {
  var answer = 0

  while (storey > 0) {
    const lastNum = storey % 10
    const nextNum = Math.floor(storey / 10) % 10

    if (lastNum < 5) {
      answer += lastNum
      storey = Math.floor(storey / 10)
    } else if (lastNum == 5) {
      answer += 5
      storey =
        nextNum >= 5 ? Math.floor(storey / 10) + 1 : Math.floor(storey / 10)
    } else {
      answer += 10 - lastNum
      storey = Math.floor(storey / 10) + 1
    }
  }

  return answer
}

/*
마법의 세계. 엘리베이터. -1, +1, 등등. 절댓값 10c? 버튼을 누르면 현재 층수의 버튼에 적힌 값을 더 한 층으로 이동한다. 엘리베이터가 위치해있는 층과 버튼. 0보다 작으면 움직이지 않는다. 0층이 가장 아래층. 마법의 돌. +1이 적힌 버튼 4번, -10이 적힌 버튼 2번. 마법의 돌 6개. 
최소한의 버튼을 눌러서 이동. 마법의 돌의 최소 갯수. storey가 주었다. 
최대한 마법의 돌을 적게 사용해서, 0층에 도달하게 만들어라. 그리디 문제. 
*/

/*
[-1, +1, -10, +10, -100, +100, -1000, +1000]
최대한 적게 사용한 것을 통해서 정답에 도달하게 만드는 방법. 
이것을 위해서는 가능하면 가장 큰 값을 먼저 활용한다. 그런데 무조건 가장 큰 값을 활용한다고 정답이 되는 것은 아니다. 특정 값으로 +,- 하기전에 어떤 값을 대입하는 것이 유익이 될 것인지 판단해야한다. 이걸 어떻게 판단하지? 
만약 2554라고 한다면. -1을 4번, -1000을 2번, -100을 5번, 50을 5번. 이렇게 하면 16번이다. 
만약 2647이라고 한다면. +1을 3번, -10을 5번, +100을 4번, -1000을 3번 => 15번 하는 방법이 있고, +1을 3번, -10을 5번, -100을 6번, -1000을 2번 하는 방법이 있다 => 16번
그러면 여기서 나오는 결론은 각 자릿수별로 해당 숫자가 5이하의 숫자인지, 5이상의 숫자인지를 판별하는 것이 중요한 것 같다. 각 자릿수가 5이상이면, +를 하고, 5이하이면 -를 하는 방식으로 접근하는 것이 좋을 것 같다. 
2657이라면? +1을 3번, +10을 4번, +100을 3번, -1000을 3번하는 방법이 있고 => 13번 
+1 3번, -10 6번, -100 6번, -1000 2번 하는 방법이 있다 => 17번.

풀이 계획 : 
1.storey가 0이 될때까지 while문을 돌린다. 
2.storey의 가장 작은 자릿수부터 해당 숫자가 5이하인지, 5이상인지를 판단한다. 
3.5이하라면, 해당 숫자 만큼 count를 += 한다. 
4.5이상이라면, 해당 숫자만큼 count를 += 하고, 다음 자릿수에도 +1한다. 
5.2번부터 다시 반복한다. 
6.storey가 0이 되면 count를 반환한다.


7.만약 값이 5라면, 무엇이 유익한지는 다시 판단해야한다. 앞의 자릿수에 1을 더했을 때, 5미만인지, 5초과인지 다시 확인해야한다. 하지만 앞의 자릿수에 1을 더했을 때 또 5가 된다면, 또 이 검증의 과정을 다시 거쳐야 한다. 
*/
