#---------요구 사항에 따른 적절한 알고리즘 설계

# n의 범위가 500인 경우 : 시간복잡도는 o(n^3)의 알고리즘을 설계하면 된다. 

# n의 범위가 2000인 경우 : 시간복잡도는o(n^2)인 알고리즘을 설계하면 된다. 

# n의 범위가 100,000인 경우 : 시간 복잡도가 o(NlogN)인 알고리즘을 설계하면 문제를 풀 수 있다. 

# n의 범위가 10,000,000인 경우 : 시간 복잡도가 o(n)인 알고리즘을 설계하면 문제를 풀 수 있다. 

# 문제푸는 과정 
# 1.지문읽기 및 컴퓨터적 사고 : 굉장히 세세하게 요구사항을 쪼개보기. 
# 2.요구사항 분석하기 
# 3.문제 해결을 위한 아이디어를 찾기 : 항상 핵심 아이디어를 캐치하면 문제를 손쉽게 코드를 작성할 수 있도록 만드려고 한다. 먼저는 문제를 온전히 이해하고, 어떤 식으로 코드를 작성해나갈지 정리한 다음에 구현을 해나가는 것이 좋다. 

# 시간 측정의 방법
# import time 
# start_time = time.time() #측정 시작 

# end_time = time.time() #측정 종료 
# print(end_time - start_time) #측정 시간 



# -----------자료형
# 정수형 

#정수형과 실수형이 가장 핵심적으로 사용된다. 정수형은 양의정수, 음의 정수, 0ㅇ이 포함된다.  1000, -7, 0 등등이 정수형이라고 할 수 있다. 

a = 777
print(a)

#실수형 

#소수점 아래의 데이터를 포함하는 수 자료형이다. 파이썬에선 변수에 소수점을 붙인 수를 대입하면 실수형 변수로 처리한다. 0.7이라면 그냥 .7이라고만 붙여도 된다. 

#파이썬에서는 e나 E를 이용한 지수 표현 방식을 이용할 수 있다. 지수표현방식 또한 많이 사용된다. 최단 경로 알고리즘이나, 그래프 알고리즘에서는 도달할 수 없는 노드에 대하여 무한으로 설정하곤 한다. 1e9는 무한으로 사용된다. 1e9(10억), a = 75.24e1 , a = 3954e-3 
a = int(1e9)
print(a)

#이진수에서는 0.9를 정확하게 표현할 수 있는 방법이 없다. 때문에 컴퓨터는 최대한 0.9와 가깝게 표현한다. 그렇지만 미세한 오차가 발생할 수 있다. 어쩔 수 없이 표현상의 정확도 한계를 가진다. 

#표현상의 한계를 극복하기 위해서 round()함수를 이용하는 것을 권장한다. 소수점 아래 몇개까지만 사용할 수 있다. 123.456을 소수점 셋째자리에서 반올림하려면 round(123.456,2)라고 작성한다. 결과는 123.46이 된다. 

a = 0.3 + 0.6 
print(round(a,4))

#파이썬에서는 기본적으로 나누기(/) 연산자를 수행했을 때, 결과를 실수형으로 반환한다. 목을 얻기 위한 몫연산자(//), 거듭 제곱 연산자(**)

#---리스트 자료형 

#데이터를 연속적으로 담아 처리하기 위해 사용하는 자료형이다. 일단적인 배열과 비교했을 때, 더 다양한 기능을 기능을 파이썬은 제공한다. 

#리스트 초기화 : ([])와 같은 방식으로 가능. list()로 선언 가능. 리스트의 원소에 접근할 때는 인덱스 값을 넣는다. 

#슬라이싱 : 대괄호 안에 :를 넣어서 시작 인덱스와 끝 인덱스를 설정할 수 있다. 끝 인덱스는 실제 인덱스보다 1을 더 크게 설정한다. 

a = [1,2,3,4,5,6,7,8]
print(a[1:4])

#리스트 컴프리헨션 : 리스트를 초기화하는 방법. 대괄호 안에 조건문과 반복문을 적용하여 리스트를 초기화할 수 있다. 짧게 코드를 작성할 수 있다는 장점이 있다. 

array = [ i for i in range(10)]
print(array)

# 0부터 19까지 수 중에서 홀수만 포함하는 리스트
#리스크 컴프리헨션
array = [ i for i in range(20) if i % 2 == 1]
print(array)

#1부터 9까지의 수들의 제곱값을 포함하는 리스트 
array = [i * i for i in range(1, 10)]
print(array)

#리스트 컴프리헨션은 이차원 리스트를 사용할 때 매우 유용하다. 
#NxM 크기의 2차원 리스트를 한번에 초기화 해야 할 때 매우 유용하다. 
# array = [[0] * m for _ in range(n)] # 좋은 예시 

# array = [[0] * m] * n #잘못된 예시 , 내부적으로 모든 객체가 같은 객체로 인식되는 문제점이 있다. 

n = 4 
m = 3 
array = [[0] * m for _ in range(n)]



# --- 언더바는 언제 사용하나요?
#반복을 수행하되 반복을 위한 변수의 값을 무시하고자 할 때 언더바를 사용한다. 

summary = 0 
for i in range(1, 10) : 
    summary += i 
print(summary)


for _ in range(5):
    print("hello")


#리스트에서 특정 값을 가지는 원소를 모두 제거하기 
a = [1,2,3,4,5,5,5]
remove_set = {3,5}

result = [ i for i in a if i not in remove_set]
print(result)



# --- 문자열 자료형 
# 문자열 타입은 특정 인덱스에 할당이 불가하다. 


#--- 튜플 자료형
#한번 선언된 값은 바꿀 수 없다. 튜플은 소괄호(())를 사용한다. 
#튜플은 리스트에 비해 상대적으로 공간 효율적이다. 더 적은 메모리를 사용한다. 

a = (1,2,3,4,5,6,7,8)

print(a[3]) #사용될 때는 리스트와 마찬가지로 사용된다. 
print(a[1:4]) 

# a[2] = 7 이와 같이 할당하려고 할 때는 문제가 된다. 

# 튜플을 사용하면 좋은 경우 
# 서로 다른 성질의 데이터를 묶어서 관리해야 할 때, 
#  최단 경로 알고리즘에서는 비용,노드 번호의 형태로 튜플 자료형을 자주 사용한다. 
# 해싱의 키 값으로 사용해야 할 때 : 튜플은 변경이 불가능하므로 리스트와 다르게 키 값으로 사용될 수 있다. 
#  리스트보다 메모리를 더 효율적으로 사용해야 할 때이다. 

# --- 사전 자료형 
#  사젼 자료형은 키와 값의 쌍을 데이터로 가지는 자료형이다. 
# 파이선의 사전 자료형은 해시 테이블을 이용한다. 사전 자료형은 사전과 같이 어떤 키 값과 같이 사용했을 때, 효과적으로 사용할 수 있다. 

a = dict()
a['홍길동'] = 97
a['이순신'] = 98

print(a)

b = {
    '홍길동' : 97,
    '이순신' :98
}

print(b)

key_list = list(b.keys())
print(key_list)


#--- 집합 자료형 
# 집합은 다음과 같은 특징이 있다. 1) 중복 허용x 2) 순서가 없습니다. 

data = set([1,1,2,3,4,4,5])
print(data)

#합집합, 교집합, 차집합 
#합집합 a | b
#교집합 a & b
#차집합 a - b

data = set([1,2,3])

data.add(4)
print(data)

#사전 자료형과 집합자료형은 순서가 없기 때문에 인덱싱으로 값을 얻을 수 없다. 시전의 키 혹은 집합의 원소를 이용해서 0(1)의 시간 복잡도로 조회한다.




#---입출력 

#input()함수는 한줄의 문자열을 입력 받는 함수이다. 
#map()함수는 리스트의 모든 원소에 각각 특정한 함수를 적용할 때 사용한다. 
#예시) 공백을 기준으로 구분된 데이터를 입력 받을 때는 다음과 같이 사용한다. 
# list(map(int,input().split()))
#예시) 공백을 기준으로 구분된 데이터의 개수가 많지 않다면, 단순히 다음과 같이 사용한다. 
#a,b,c = map(int, input().split())

#데이터의 개수 입력 
# n = int(input())

#각 데이터를 공백을 기준으로 구분하여 입력 
# data = list(map(int, input().split()))

# data.sort(reverse=True)
# print(data)

#빠르게 입력받기 
#사용자로부터 입력을 최대한 빠르게 받아야 하는 경우.
#파이썬의 경우 sys 라이브러리에 정의되어 있는 sys.stdin.readline()메서드를 이용한다. 
#단, 입력 후 엔터가 줄 바꿈 기호로 입력되므로 rstrip()메서드를 함께 사용한다. 

# import sys 
 
# data = sys.stdin.readline().rstrip()

#자주 사용되는 표준 출력 방법 
#파이썬에서 기본 출력은 print()함수를 이용한다. 
#print()는 기본적으로 출력 이후에 줄 바꿈을 수행합니다. -> 줄바꿈을 원하지 않는 경우 'end' 속성을 이용할 수 있습니다. 
a = 1
b = 2
print(a,b)
print(7, end=" ") #이어서 사용하고자 할 때.
print(8, end=" ")

#출력할 변수 
answer = 7
print("정답은" + str(answer) + "입니다.")

#-----f-string 예제 
answer = 7
print(f"정답은 {answer}입니다.");



#--- 조건문과 반복문 
#조건문은 프로그램의 흐름을 제어하는 문법이다. 

x = 15 
if x >= 10:
    print("x>= 10")

#in 연산자 not in 연산자 
#리스트, 튜플, 문자열, 딕셔너리 모두에서 사용가능하다. 

#pass 키워드 
#특정 코드를 사용하지 않으려고 할 때. 
score = 85

if score >= 80 :
    pass # 나중에 작성할 소스코드. 

#파이썬에서는 조건문 안에서의 수학의 부등식을 그대로 사용할 수 있습니다. 
x = 15
if x > 0 and x < 20:
    print('x는 0이상 20 미만의 수입니다.')

x = 15
if 0 < x <20 : 
    print('x는 0 이상 20미만의 수입니다.')


#--- 반복문 

i = 1
result = 0 

while i <= 9:
    result += i 
    i += 1 

print(result)

#반복문으로 for문을 이용할 수 있다. for문의 구조는 다음과 같은데, 특정한 변수를 이용하여 'in' 뒤에 오는 데이터에 포함되어 있는 원소를 첫 번째 인덱스부터 차례대로 하나씩 방문합니다. 

#for 변수 in 리스트 : 
#  실행할 소스코드  

array = [9,8,7,6,5]

for x in array : 
    print(x)

#for문에서 연속적인 값을 차례대로 순회할 때는 range()를 주로 사용한다. 
# 이때 range(시작값, 끝 값 + 1)형태로 사용된다. 

#continue키워드 
result = 0 

for i in range(1,10):
    if i % 2 == 0:
        continue
    result += i 

print(result)

while True :
    if i == 5:
        break


# 특정 번호의 학생은 제외하기.
scores = [90, 85, 77, 65, 97]
cheating_student_list = {2,4}

for i in range(5):
    if i + 1 in cheating_student_list:
        continue
    if scores[i] >= 80:
        print(i + 1, "번 학생은 합격입니다. ")


#---- 함수와 람다 표현식 
#함수란 특정 작업을 하나의 단위로 묶어 놓은 것을 의미한다. 
#함수를 사용하면 불필요한 소스코드의 반복을 줄일 수 있습니다. 

#내장함수 : 파이썬이 기본적으로 제공하는 함수 
#사용자 정의 함수 : 개발자가 직접 정의하여 사용할 수 있는 함수 

# def add(a,b):
#     return a + b
# print(add(3,7))

def add(a,b):
    print('함수의 결과', a + b)

add(3,7)

#global 키워드 

a = 0

def func():
    global a # 함수 바깥에 있는 변수를 사용하기 위한 global
    a += 1

for i in range(10):
    func()

print(a)

#함수는 항상 내부에 있는 변수를 우선순위로 생각한다. 

#여러개의 반환 값을 파이썬 함수는 가질 수 있다. 

def operator(a,b):
    add_var = a + b
    subtract_var = a - b
    multiply_var = a * b 
    divide_var = a / b
    return add_var, subtrack_var, multiply_var, divide_var

a,b,c,d = operator(7,3)
print(a,b,c,d)


#람다 표현식 
#함수를 간단하게 작성할 수 있다. 

def add(a,b):
    return a + b

#람다 표현식으로 구현한 add() 메서드, 함수의 이름이 필요없다. 
print((lambda a,b:a+b(3,7)))


# 람다 예시 
array = [('홍길동', 50), ('이순신', 32), ('아무개', 74)]

def my_key(x):
    return x[1]

# 함수를 정렬하되, 특정 기준으로 정렬을 하겠다는 말이다. 
print(sorted(array, key=my_key))
# 한번 사용되고 말 함수이기 때문에, 아래와 같이 람다를 사용하는 경우 적합하다. 
print(sorted(array, key=lambda x:x[1]))

# 람다 예시 : 여러개의 리스트의 적용 
list1 = [1,2,3,4,5]
list2 = [6,7,8,9,10]

# 앞에 있는 람다 함수를 뒤에 있는 리스트1,2에 적용을 하는 것이다. 
result = map(lambda a,b: a + b , list1, list2)

#실전에서 유용한 표준 라이브러리 
#내장 함수 :
#itertools 모든 경우의 수를 고려해야 할 때 사용. 
#headq
#bisect
#collections
#math

# 순열 : 서로 다른 n개에서 서로 다른 r개를 선택하여 일렬로 나열하는 것. 

