# 현재 상황에서 지금 당장 좋은 것만 고르는 방법을 의미한다. 
# 해당 문제를 풀기위한 최소한의 아이디어를 떠올리는 것이 가장 중요하다. 
# 최적의 해를 구할 수 있는지를 검토한다. 

#문제 : 루트노드부터 시작해서, 거쳐가는 노드값의 합을 최대로 만들고 싶다고 한다. 
#단순히 매 상황에서 가장 큰 값만 고른다면 어떻게 될까? 
#그리디 알고리즘은 매 상황에서 가장 큰 값만 고르는 방식이다. 때문에 그리디 알고리즘은 최적의 해를 보장할 수 없을 때가 많다. 하지만, 코딩 테스트에서는 그리디 문제는 탐욕법으로 얻은 해가 최적의 해가 되는 상황에서, 이를 추론할 수 있어야 풀리도록 출제가 된다. 탐욕법으로 얻은 해가 최적의 해가 되는 경우에 문제를 출제하는 경우가 많다. 

#거스름돈 문제 : 가장 큰 화폐 단위부터 돈을 거슬러주면 된다. 
#정당성 분석 : 가지고 있는 동전 중에서 큰 단위가 항상 작은 단위의 배수이므로 작은 단위의 동전들을 종합해 다른 해가 나올 수 없기 때문이다.  
#그리디는 최소한의 아이디어를 떠올리고, 이것이 정당한지 검토할 수 있어야 한다. 

n = 1260
count = 0 

array = [500, 100, 50, 10]

for coin in array :
    count += n // coin 
    n %= coin 

print(count)


#1이 될때 까지. 

#주어진 N에 대하여 최대한 많이 나누기를 수행하면 된다. 
#N의 값을 줄일 때 2 이상의 수로 나누는 작업이 1을 빼는 작업보다 수를 훨씬 많이 줄일 수 있다. 

#가능하면 최대한 많이 나누는 작업이 최적의 해를 항상 보장할 수 있을까요? 
#N이 아무리 큰 수여도, K로 계속 나눈다면 기하급수적으로 빠르게 줄일 수 있습니다. 
#다시 말해 K가 2 이상이기만 하면, k로 나누는 것이 1을 빼는 것보다 항상 빠르게 n을 줄일 수 있습니다. 

n, k = map(int, input().split())

result = 0 

while True: 
    #N이 K로 나누어 떨어지는 수가 될 떄까지 빼기 
    target = (n//k) * k #n을 k로 나눈 몫에 다시 k를 곱한다.이렇게하면 가장 가깝게 나누어 떨어지는 수를 찾을 수 있다. 
    result += (n-target) #연산을 총 수행할 횟수 
    n = target
    
    #N이 K보다 작을 때 (더 이상 나눌 수 없을 때) 반복문 탈출 
    if n < k :
        break
    #K로 나누기 
    result += 1 
    n //= k 

result += (n-1)
print(result)


# 곱하기 혹은 더하기 : 문제설명 

#1.문자열 하나하나를 확인한다. 2.문자열이 0일 경우를 제외하고 모든 숫자는 x를 적용한다. 3. 0일 경우에는 더하기를 적용한다. 

data = input()

result = int(data[0])

for i in range(1, len(data)):
    num = int(data[i])
    if num <= 1 or result <= 1:
        result += num 
    else:
        result *= num 
print(result)


#모험가 길드: 문제 설명 
#1.오름차순 정렬을 해서, 가장 낮은 모험가부터 하나씩 확인한다. 
#2.

n = int(input())
data = list(map(int, input().split()))
data.sort()

result = 0 #총 그룹 수
count = 0  # 현재 그룹에 포함된 모험가의 수 

for i in data : #공포도를 낮은 것부터 하나씩 확인하며
    count += 1 #현재 그룹에 해당 모험가를 포함시키기
    if count >= i :
        result += 1 
        count = 0 

print(result)


#구현 : 구현이란 알고리즘을 소스코드로 바꾸는 과정이다. 어떤 알고리즘을 풀어도 결국에는 코드로 구현해내야 한다.
#구현 유형의 문제는 : 풀이를 떠올리는 것은 쉽지만 소스코드로 옮기기 어려운 문제. 

#코딩테스트에서도 2차원 공간을 가정하는 문제가 많이 등장한다.

#---------- 상하좌우 : 문제설명 

# R이면 y += 1 
# U이면 x -= 1
# D이면 x += 1

n = int(input())
x,y = 1,1
plans = input().split()

#L,R,U,D에 다른 이동 방향 
dx = [0,0,-1,1]
dy = [-1,1,0,0]
move_types = ['L','R','U','D']

#이동 계획을 하나씩 확인하기 
for plan in plans:
    #이동 후 좌표 구하기 
    for i in range(len(move_types)):
        if plan == move_types[i]:
            nx = x + dx[i]
            ny = y + dy[i]

    #공간을 벗어나는 경우 무시 
    if nx < 1 or ny < 1 or nx > n or ny > n :
        continue
    x, y = nx, ny

print(x,y)


#-------시각 : 문제설명 
#정수 N이 입력되면 00시 00분 00초부터 N시 59분 59초까지의 모든 시각 중에서 3이 하나라도 포함되는 모든 경우의 수를 구하는 프로그램을 작성하세요. 예를 들어 1을 입력했을 때 다음은 3이 하나라도 포함되어 있으므로 세어야 하는 시각입니다. 

#가능한 모든 시각의 경우를 하나씩 모두 세서 풀 수 있는 문제이다. : 완전 탐색 문제이다. 24*60*60. 브루트 포스문제. 가능한 모든 경우의 수를 탐색해보는 문제이다. 
h = int(input())

count = 0 
for i in range(h + 1):
    for j in range(60):
        for k in range(60):
            if '3' in str(i) + str(j) + str(k):
                count += 1

print(count)


#------왕실의 나이트 : 문제설명 
#행복 왕국의 왕실 정원은 체스판과 같은 8x8 좌표평명입니다. 왕실 정원의 특정한 한 칸에 나이트가 서 있습니다. 나이트는 말을 타고 있기 대문에 이동을 할 때는 L자 형태로만 이동할 수 있으며 정원 밖으로는 나갈 수 없습니다. 
#나이트는 특정 위치에서 다음과 같은 2 가지 경우로 이동할 수 있습니다. 
#1.수평으로 두 칸 이동한 뒤에 수직으로 한 칸 이동하기 
#2. 수직으로 두 칸이동한 뒤에 수평으로 한 칸 이동하기 

#요구사항대로 충실히 구현하면 되는 문제이다. 
#나이트의 8가지 경로를 하나씩 확인하며

input_data = input()
row = int(input_data[1])
column = int(ord(input_data[0])) - int(ord('a')) + 1 #아스키 코드로 변환하기. 

steps = [(-2,-1), (-1,-2), (1,-2), (2,-1), (2,1), (1,2), (-1,2),(-2,1)] # 각각 하나하나가 방향벡터라고 보면 된다. 

#8갖 방향에 대하여 각 위치로 이동이 가능한지 확인 
result = 0 
for step in steps : 
    #이동하고자 하는 위치 확인 
    next_row = row + step[0]
    next_column = column + step[1]
    #해당 위치로 이동이 가능하다면 카운트 증가 
    if next_row >= 1 and next_row <= 8 and next_column >= 1 and next_column <= 8:
        result += 1

print(result)

#-----알파벳 재정렬 문제 
#알파벳 대문자와 숫자로만 구성된 문자열이 입력으로 주어집니다. 이때 모든 알파벳을 오름차순으로 정렬하여 이어서 출력한 뒤에, 그 뒤에 모든 숫자를 더한 값을 이어서 출력합니다. 
#수와 숫자의 차이. 

#문자열이 입력되었을 때 문자를 하나씩 확인한다. 
#숫자인 경우 따로 합계를 계산한다. 
#알파벳인 경우 별도의 리스트에 저장한다. 


data = input()
result = []
value = 0

for x in data:
    #알파벳인 경우 결과 리스트에 삽입
    if x.isalpha():
        result.append(x)
    #숫자는 따로 더하기 
    else:
        value += int(x)

#알파벳을 오름차순으로 정렬 
result.sort()

#숫자가 하나라도 존재하는 경우 가장 뒤에 삽입
if value != 0 :
    result.append(str(value))

#최종 결과 출력(리스트를 문자열로 변환하여 출력)
print(''.join(result))